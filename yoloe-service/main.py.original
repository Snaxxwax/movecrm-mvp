from fastapi import FastAPI, File, UploadFile, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional, Dict, Any
import uvicorn
import os
import json
import asyncio
import aiofiles
import tempfile
import shutil
from datetime import datetime
import logging

from src.yoloe_detector import YOLOEDetector
from src.runpod_client import RunPodClient
from src.models import DetectionRequest, DetectionResponse, JobStatus

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="MoveCRM YOLOE Detection Service",
    description="AI-powered item detection service for moving quotes",
    version="1.0.0"
)

# Enable CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global instances
yoloe_detector = None
runpod_client = None

# Configuration
UPLOAD_DIR = "/tmp/yoloe_uploads"
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
ALLOWED_EXTENSIONS = {".jpg", ".jpeg", ".png", ".mp4", ".mov", ".avi"}

# In-memory job storage (in production, use Redis or database)
active_jobs: Dict[str, Dict[str, Any]] = {}

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    global yoloe_detector, runpod_client
    
    # Create upload directory
    os.makedirs(UPLOAD_DIR, exist_ok=True)
    
    # Initialize YOLOE detector
    try:
        yoloe_detector = YOLOEDetector()
        logger.info("YOLOE detector initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize YOLOE detector: {str(e)}")
        yoloe_detector = None
    
    # Initialize RunPod client
    try:
        runpod_api_key = os.getenv("RUNPOD_API_KEY")
        if runpod_api_key:
            runpod_client = RunPodClient(runpod_api_key)
            logger.info("RunPod client initialized successfully")
        else:
            logger.warning("RunPod API key not found, RunPod features disabled")
    except Exception as e:
        logger.error(f"Failed to initialize RunPod client: {str(e)}")
        runpod_client = None

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown"""
    # Clean up temporary files
    if os.path.exists(UPLOAD_DIR):
        shutil.rmtree(UPLOAD_DIR)

def validate_file(file: UploadFile) -> bool:
    """Validate uploaded file"""
    if not file.filename:
        return False
    
    # Check file extension
    file_ext = os.path.splitext(file.filename)[1].lower()
    if file_ext not in ALLOWED_EXTENSIONS:
        return False
    
    return True

async def save_uploaded_file(file: UploadFile) -> str:
    """Save uploaded file and return path"""
    if not validate_file(file):
        raise HTTPException(status_code=400, detail="Invalid file type")
    
    # Create unique filename
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{timestamp}_{file.filename}"
    file_path = os.path.join(UPLOAD_DIR, filename)
    
    # Save file
    async with aiofiles.open(file_path, 'wb') as f:
        content = await file.read()
        if len(content) > MAX_FILE_SIZE:
            raise HTTPException(status_code=400, detail="File too large")
        await f.write(content)
    
    return file_path

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "yoloe_available": yoloe_detector is not None,
        "runpod_available": runpod_client is not None
    }

@app.post("/detect/auto", response_model=DetectionResponse)
async def detect_auto(
    background_tasks: BackgroundTasks,
    files: List[UploadFile] = File(...),
    job_id: Optional[str] = None
):
    """Automatic item detection without prompt"""
    try:
        if not yoloe_detector:
            raise HTTPException(status_code=503, detail="YOLOE detector not available")
        
        if not files:
            raise HTTPException(status_code=400, detail="No files provided")
        
        # Generate job ID if not provided
        if not job_id:
            job_id = f"auto_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Initialize job status
        active_jobs[job_id] = {
            "status": "processing",
            "created_at": datetime.now().isoformat(),
            "files_count": len(files),
            "detections": []
        }
        
        # Save uploaded files
        file_paths = []
        for file in files:
            try:
                file_path = await save_uploaded_file(file)
                file_paths.append(file_path)
            except Exception as e:
                logger.error(f"Failed to save file {file.filename}: {str(e)}")
                continue
        
        if not file_paths:
            active_jobs[job_id]["status"] = "failed"
            active_jobs[job_id]["error"] = "No valid files to process"
            raise HTTPException(status_code=400, detail="No valid files to process")
        
        # Process files in background
        background_tasks.add_task(process_auto_detection, job_id, file_paths)
        
        return DetectionResponse(
            success=True,
            job_id=job_id,
            status="processing",
            message=f"Processing {len(file_paths)} files"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Auto detection error: {str(e)}")
        if job_id and job_id in active_jobs:
            active_jobs[job_id]["status"] = "failed"
            active_jobs[job_id]["error"] = str(e)
        raise HTTPException(status_code=500, detail="Detection failed")

@app.post("/detect/text", response_model=DetectionResponse)
async def detect_text(
    background_tasks: BackgroundTasks,
    request: DetectionRequest
):
    """Text-based item detection with prompt"""
    try:
        if not yoloe_detector:
            raise HTTPException(status_code=503, detail="YOLOE detector not available")
        
        if not request.prompt:
            raise HTTPException(status_code=400, detail="Prompt is required")
        
        if not request.files:
            raise HTTPException(status_code=400, detail="No files provided")
        
        # Generate job ID if not provided
        job_id = request.job_id or f"text_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        # Initialize job status
        active_jobs[job_id] = {
            "status": "processing",
            "created_at": datetime.now().isoformat(),
            "prompt": request.prompt,
            "files_count": len(request.files),
            "detections": []
        }
        
        # Process files in background
        background_tasks.add_task(process_text_detection, job_id, request.files, request.prompt)
        
        return DetectionResponse(
            success=True,
            job_id=job_id,
            status="processing",
            message=f"Processing {len(request.files)} files with prompt"
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Text detection error: {str(e)}")
        if request.job_id and request.job_id in active_jobs:
            active_jobs[request.job_id]["status"] = "failed"
            active_jobs[request.job_id]["error"] = str(e)
        raise HTTPException(status_code=500, detail="Detection failed")

@app.get("/jobs/{job_id}", response_model=JobStatus)
async def get_job_status(job_id: str):
    """Get job status and results"""
    if job_id not in active_jobs:
        raise HTTPException(status_code=404, detail="Job not found")
    
    job_data = active_jobs[job_id]
    
    return JobStatus(
        job_id=job_id,
        status=job_data["status"],
        created_at=job_data["created_at"],
        completed_at=job_data.get("completed_at"),
        files_count=job_data.get("files_count", 0),
        detections=job_data.get("detections", []),
        error=job_data.get("error")
    )

@app.get("/jobs")
async def list_jobs():
    """List all jobs"""
    return {
        "jobs": [
            {
                "job_id": job_id,
                "status": job_data["status"],
                "created_at": job_data["created_at"],
                "files_count": job_data.get("files_count", 0)
            }
            for job_id, job_data in active_jobs.items()
        ]
    }

async def process_auto_detection(job_id: str, file_paths: List[str]):
    """Process automatic detection in background"""
    try:
        all_detections = []
        
        for file_path in file_paths:
            try:
                # Detect items in image/video
                detections = await yoloe_detector.detect_items(file_path)
                
                # Add file info to detections
                for detection in detections:
                    detection["file_path"] = file_path
                    detection["file_name"] = os.path.basename(file_path)
                
                all_detections.extend(detections)
                
            except Exception as e:
                logger.error(f"Detection failed for {file_path}: {str(e)}")
                continue
            finally:
                # Clean up file
                try:
                    os.remove(file_path)
                except:
                    pass
        
        # Update job status
        active_jobs[job_id]["status"] = "completed"
        active_jobs[job_id]["completed_at"] = datetime.now().isoformat()
        active_jobs[job_id]["detections"] = all_detections
        
        logger.info(f"Auto detection job {job_id} completed with {len(all_detections)} detections")
        
    except Exception as e:
        logger.error(f"Auto detection job {job_id} failed: {str(e)}")
        active_jobs[job_id]["status"] = "failed"
        active_jobs[job_id]["error"] = str(e)

async def process_text_detection(job_id: str, files: List[Dict], prompt: str):
    """Process text-based detection in background"""
    try:
        all_detections = []
        
        for file_info in files:
            try:
                file_path = file_info.get("file_path")
                if not file_path or not os.path.exists(file_path):
                    logger.warning(f"File not found: {file_path}")
                    continue
                
                # Detect items with prompt
                detections = await yoloe_detector.detect_items_with_prompt(file_path, prompt)
                
                # Add file info to detections
                for detection in detections:
                    detection["file_path"] = file_path
                    detection["file_name"] = file_info.get("file_name", os.path.basename(file_path))
                    detection["file_id"] = file_info.get("file_id")
                
                all_detections.extend(detections)
                
            except Exception as e:
                logger.error(f"Text detection failed for {file_info}: {str(e)}")
                continue
        
        # Update job status
        active_jobs[job_id]["status"] = "completed"
        active_jobs[job_id]["completed_at"] = datetime.now().isoformat()
        active_jobs[job_id]["detections"] = all_detections
        
        logger.info(f"Text detection job {job_id} completed with {len(all_detections)} detections")
        
    except Exception as e:
        logger.error(f"Text detection job {job_id} failed: {str(e)}")
        active_jobs[job_id]["status"] = "failed"
        active_jobs[job_id]["error"] = str(e)

if __name__ == "__main__":
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8001,
        reload=True
    )

